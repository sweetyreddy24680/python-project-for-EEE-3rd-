# -*- coding: utf-8 -*-
"""sweety.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gOcnr5S5oRJ3zzeg5fxPyshBruyTMgld
"""

name=input("Enter your name:")
age=int(input("Enter your age:"))
print("Hello",name,"you are",age)

text="Python is Fun"
print(text.replace("Fun","notfun"))
print(text[0:6])

def torque(force,radius):
  return force*radius
print("Torque:",torque(50,0.3),"N.m")

machine={"name":"Lathe","power":5.5,"unit":"kw"}
print("Machine:",machine["name"])
print("power:",machine["power"],machine["unit"])

#mechanical engneering=set:unique tools



tools={"wrench","hammer","screwdriver","hammer"}
print("Unique tools:",tools)

#civil engnerring-structure:slab volume

def slab_volume(length,width,thickness):
  return length*width*thickness
print("volume:",slab_volume(5,4,0.15),"m^3")

#civil engineering-Dictonery:projectdetails

project={"name":"Bridge","length":150,"status":"Ongoing"}
print("project:",project["name"])
print("length:",project["length"],"meters")

#civil Engineering=loop:area of traingle by loops

bases=[10,15,20]
height=[5,8,12]
for base,height in zip(bases,height):
  area=0.5*base*height
  print(f"Area with bases{base}and height{height}:{area}m^2")

#eee-set:unique components

components={"resistor","capactior","inductor","resistor"}
print("Unique components:",components)

#eee-structure:ohm's law calculator

def voltage(current,resistance):
  return current*resistance

print("Voltage:",voltage(2.5,10),"Volts")

#EEE-LOOP:POWER CALCULATION

voltages=[230,120,12]
currents=[5,10,0.5]

for V,I in zip(voltages,currents):
  power=V*I
  print(f"Power for {V}V and{I}A:{power}Watts")

class Concreteslab:
 def __init__(self,l,b,h,cost_per_m3):
    self.l=l
    self.b=b
    self.h=h
    self.cost_per_m3=cost_per_m3
 def volume(self):
   return self.l*self.b*self.h
 def total_cost(self):
   return self.volume()*self.cost_per_m3
slab=Concreteslab(10,5,0.2,3500)
print("Volume:",slab.volume(),"m3")
print("Total Cost:",slab.total_cost(),"INR")

#Three-Phase Power
import math
class ThreePhasePower:
  def __init__(self,V,I,pf):
     self.V=V
     self.I=I
     self.pf=pf
  def power(self):
     return math.sqrt(3)*self.V*self.I*self.pf
tp=ThreePhasePower(400,50,0.9)
print("Three-Phase Power:",round(tp.power(),2),"W")

#scipy for calculations
from scipy.optimize import fsolve
def eq(x):
   return 3*x**2-x-1
root=fsolve(eq,0)
print('Root:',root)

a=int(input("enter a number"))
for i in range (0,a+1):
    print(f"{i}^2={i*i}")

#data fitting

import numpy as np
from scipy.optimize import curve_fit
def model(x,a,b):
  return a*np.exp(b*x)
x=np.linspace(0,4,50)
y=model(x,2,0.5)+np.random.normal(0,0.2,50)
popt,_=curve_fit(model,x,y)
print(popt)

#tkinter gul



import tkinter as tk
 def Calc():
   F=float(entry_force.get())
   A=float(entry_area.get())
   result.set(F/A)
 root=tk.Tk()
 entry_force=tk.entry(root)
 entry_area=tk.entry(root)
 result=tk.StringVar()
 tk.Button(root,text='Calc',command=Calc).pack()
 tk.Label(root,textvariable=result).pack()
 root.mainloop()

import cmath
V=230;z=10+5j
l=V/z
print(l)

import numpy as np
arr=np.array({4,6,9})
print(arr)

thirdyear_list=[{10,50,100}]
print("original:",thirdyear_list)
thirdyear_list.append(90)
thirdyear_list[1]=90
print("updated",thirdyear_list)

student_tuple=([1,2,4,5,6,7,8,9,19])
print("original",student_tuple)

student_tuple=(1,2,3,4,5,6,7,8,9,10)
print("updated",student_tuple)
New_tuple=student_tuple+(15,)
print("New_tuple",New_tuple)



class Address:
    def __init__(self, Street, city, state):
        self.Street = Street
        self.city = city
        self.state = state

s1 = Address("kvr petrol bunk", "Nellore", "AP")
print(s1.Street, s1.city, s1.state)

n=int(input("Enter N value"))
for i in range(n):
  for j in range(i+1):
    print('*',end='')
  print()

n = 5
for i in range(1, n+1):
    print(" " * (n - i) + "* " * i)



try:
  data=float(input('Enter load value'))
except ValueError:
  print('lnvalid input!')

from scipy.optimize import fsolve
def eq(x):
  return 3*x**2-x-1
root = fsolve(eq,0)
print('Root:',root)

import numpy as np
samples=np.random.normal(50,5,10000)
failure_rate=np.mean(samples>60)
print('Failure Rate:',failure_rate*100,'%')

import numpy as np
from scipy.optimize import curve_fit
def model(x,a,b):
  return a*np.exp(b*x)
x=np.linspace(0,4,50)
y=model(x,2,0.5)+np.random.normal(0,0.2,50)
popt,_=curve_fit(model,x,y)
print(popt)



import pandas as pd

df = pd.read_excel('data.xlsx')

df['Strees']=df['force'] / df['Area']

df.to_excel('data.xlsx',index=False)

def pid_controller(setpoint, measured_speed, kp, ki, kd, dt):
    """
    Calculates the PWM duty cycle using PID control.

    Args:
        setpoint: Desired motor speed.
        measured_speed: Current motor speed.
        kp: Proportional gain.
        ki: Integral gain.
        kd: Derivative gain.
        dt: Time step.

    Returns:
        PWM duty cycle (0-255).
    """
    error = setpoint - measured_speed
    integral = integral + error * dt
    derivative = (error - previous_error) / dt
    output = kp * error + ki * integral + kd * derivative
    previous_error = error

    # Limit output to PWM range (e.g., 0-255)
    pwm_output = int(max(0, min(255, output)))

    return pwm_output

import matplotlib.pyplot as plt
import numpy as np

# Motor parameters (example values)
J = 0.01  # Moment of inertia
b = 0.1  # Damping coefficient
K = 0.01  # Motor constant
R = 1  # Armature resistance
L = 0.5  # Armature inductance

# PID controller parameters
Kp = 1  # Proportional gain
Ki = 0.1  # Integral gain
Kd = 0.01  # Derivative gain

# Simulation parameters
dt = 0.01  # Time step
simulation_time = 10  # Simulation duration
time = np.arange(0, simulation_time, dt)
setpoint = 50  # Desired motor speed

# Initialize variables
error_integral = 0
previous_error = 0
motor_speed = 0
speed_history = []

# PID control function
def pid_control(error, error_integral, previous_error, dt):
    P = Kp * error
    error_integral += error * dt
    I = Ki * error_integral
    D = Kd * (error - previous_error) / dt
    output = P + I + D
    return output, error_integral, error

# Motor model (simplified)
def motor_model(voltage, motor_speed, dt):
    # Simplified equations (adjust for your specific model)
    torque = K * voltage  # Torque is proportional to voltage
    # Assume a simple relationship between torque, damping, and inertia
    acceleration = (torque - b * motor_speed) / J
    new_speed = motor_speed + acceleration * dt
    return new_speed

# Simulation loop
for t in time:
    # Calculate error
    error = setpoint - motor_speed

    # PID control calculation
    voltage, error_integral, previous_error = pid_control(error, error_integral, previous_error, dt)

    # Motor model update
    motor_speed = motor_model(voltage, motor_speed, dt)

    # Store data
    speed_history.append(motor_speed)

# Plotting
plt.plot(time, speed_history)
plt.xlabel("Time (s)")
plt.ylabel("Motor Speed (rad/s)")
plt.title("DC Motor Speed Control with PID")
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import numpy as np
setpoint = 100  # Desired motor speed (RPM)
Kp = 0.1        # Proportional gain
Ki = 0.01       # Integral gain
Kd = 0.05       # Derivative gain
dt = 0.1        # Time step for simulation (seconds)
sim_time = 150   # Total simulation time (seconds)
integral = 0
previous_error = 0

motor_speed = 0  # Initial motor speed (RPM)

# Store data for plotting
time_data = []
speed_data = []
integral = 0
previous_error = 0

motor_speed = 0  # Initial motor speed (RPM)

# Store data for plotting
time_data = []
speed_data = []
for t in np.arange(0, sim_time, dt):
    # Calculate error between setpoint and current motor speed
    error = setpoint - motor_speed
# Proportional term
    P_out = Kp * error

    # Integral term (accumulation of past errors)
    integral += error * dt
    I_out = Ki * integral

    # Derivative term (rate of change of error)
    derivative = (error - previous_error) / dt
    D_out = Kd * derivative
# Calculate the total control output
    control_output = P_out + I_out + D_out

    # Simulate the motor speed response (simplified linear response)
    motor_speed += control_output * dt
# Update the previous error for the next iteration
    previous_error = error

    # Save data for plotting
    time_data.append(t)
    speed_data.append(motor_speed)
# Plot the motor speed over time
plt.plot(time_data, speed_data)
plt.title('DC Motor Speed with PID Control')
plt.xlabel('Time (s)')
plt.ylabel('Speed (RPM)')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Simulation parameters
setpoint = 100  # Desired motor speed (RPM)
Kp = 0.1  # Proportional gain
Ki = 0.01  # Integral gain
Kd = 0.05  # Derivative gain
dt = 0.1  # Time step (seconds)
sim_time = 150  # Simulation time (seconds)

# Motor parameters (example values)
motor_inertia = 0.01  # kg.m^2
damping_coefficient = 0.1  # N.m.s/rad
torque_constant = 0.01  # N.m/A
resistance = 1  # Ohm
inductance = 0.5  # Henry

# Controller initialization
integral = 0
previous_error = 0
motor_speed = 0  # Initial motor speed (RPM)

# Data storage for plotting
time_data = []
speed_data = []

# --- Function to calculate motor speed based on torque and load ---
def update_motor_speed(current_speed, applied_torque, dt):
    """
    Simulates the motor's speed update based on torque and load.

    Args:
      current_speed: The current motor speed in RPM.
      applied_torque: The torque applied to the motor in Nm.
      dt: The time step in seconds.

    Returns:
      The updated motor speed in RPM.
    """
    # Convert RPM to rad/s
    current_speed_rad_per_s = current_speed * (2 * np.pi / 60)

    # Calculate acceleration based on torque and load (simplified model)
    acceleration_rad_per_s2 = (applied_torque - damping_coefficient * current_speed_rad_per_s) / motor_inertia

    # Update speed (Euler integration)
    new_speed_rad_per_s = current_speed_rad_per_s + acceleration_rad_per_s2 * dt
    new_speed_rpm = new_speed_rad_per_s * (60 / (2 * np.pi))

    return new_speed_rpm

# --- PID Controller ---
def pid_control(error, integral, previous_error, dt):
    """
    Calculates the PID output for a given error.

    Args:
      error: The current error (difference between setpoint and actual value).
      integral: The accumulated integral of past errors.
      previous_error: The error from the previous iteration.
      dt: The time step.

    Returns:
      A tuple containing:
        - The PID output (control signal).
        - The updated integral value.
        - The updated previous_error value.
    """
    integral = integral + error * dt
    derivative = (error - previous_error) / dt
    output = Kp * error + Ki * integral + Kd * derivative
    return output, integral, error

# --- Simulation loop ---
for t in np.arange(0, sim_time, dt):
    # Calculate error
    error = setpoint - motor_speed

    # --- PID control ---
    torque, integral, previous_error = pid_control(error, integral, previous_error, dt)

    # Convert PID output to a torque value (example)
    # In a real system, this would likely be a PWM signal controlling a motor driver
    applied_torque = torque * 0.1  # Adjust scaling as needed


    # Update motor speed
    motor_speed = update_motor_speed(motor_speed, applied_torque, dt)

    # Store data for plotting
    time_data.append(t)
    speed_data.append(motor_speed)


# --- Plotting ---
plt.plot(time_data, speed_data)
plt.xlabel("Time (s)")
plt.ylabel("Motor Speed (RPM)")
plt.title("DC Motor Speed Control with PID")
plt.grid(True)
plt.show()



